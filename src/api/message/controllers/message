import { factories } from "@strapi/strapi";

export default factories.createCoreController(
  "api::message.message",
  ({ strapi }) => ({
    // Method 1: Creating an entirely custom action
    async exampleAction(ctx) {
      try {
        ctx.body = "ok";
      } catch (err) {
        ctx.body = err;
      }
    },

    // Method 2: Wrapping a core action (leaves core logic in place)
    async find(ctx) {
      // some custom logic here
      ctx.query = { ...ctx.query, local: "en" };
      console.log({ query: ctx.query });

      // Calling the default core action
      const { data, meta } = await super.find(ctx);

      // some more custom logic
      meta.date = Date.now();

      return { data, meta };
    },

    // Method 3: Replacing a core action with proper sanitization
    async findOne(ctx) {
      // validateQuery (optional)
      // to throw an error on query params that are invalid or the user does not have access to
      await this.validateQuery(ctx);

      // sanitizeQuery to remove any query params that are invalid or the user does not have access to
      // It is strongly recommended to use sanitizeQuery even if validateQuery is used
      const sanitizedQueryParams = await this.sanitizeQuery(ctx);
      const { results, pagination } = await strapi
        .service("api::message.message")
        .find(sanitizedQueryParams);

      // sanitizeOutput to ensure the user does not receive any data they do not have access to
      const sanitizedResults = await this.sanitizeOutput(results, ctx);

      return this.transformResponse(sanitizedResults, { pagination });
    },
    async create(ctx) {
      // validateQuery (optional)
      // to throw an error on query params that are invalid or the user does not have access to
      await this.validateQuery(ctx);

      // sanitizeQuery to remove any query params that are invalid or the user does not have access to
      // It is strongly recommended to use sanitizeQuery even if validateQuery is used
      const sanitizedQueryParams = await this.sanitizeQuery(ctx);
      const { results, pagination } = await strapi
        .service("api::message.message")
        .find(sanitizedQueryParams);

      // sanitizeOutput to ensure the user does not receive any data they do not have access to
      const sanitizedResults = await this.sanitizeOutput(results, ctx);

      return this.transformResponse(sanitizedResults, { pagination });
    },
    async delete(ctx) {
      // validateQuery (optional)
      // to throw an error on query params that are invalid or the user does not have access to
      await this.validateQuery(ctx);

      // sanitizeQuery to remove any query params that are invalid or the user does not have access to
      // It is strongly recommended to use sanitizeQuery even if validateQuery is used
      const sanitizedQueryParams = await this.sanitizeQuery(ctx);
      const { results, pagination } = await strapi
        .service("api::message.message")
        .find(sanitizedQueryParams);

      // sanitizeOutput to ensure the user does not receive any data they do not have access to
      const sanitizedResults = await this.sanitizeOutput(results, ctx);

      return this.transformResponse(sanitizedResults, { pagination });
    },
  })
);
